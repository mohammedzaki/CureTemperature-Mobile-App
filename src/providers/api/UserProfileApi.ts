/**
 * Elagy
 * Elagy APIs
 *
 * OpenAPI spec version: 1.0.0
 * Contact: mohammed.zaki@eye-ltd.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {Inject, Injectable, Optional} from '@angular/core';
import {Http, Headers, URLSearchParams} from '@angular/http';
import {RequestMethod, RequestOptions, RequestOptionsArgs} from '@angular/http';
import {Response, ResponseContentType} from '@angular/http';

import {Observable} from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models from '../../models';
import {Configuration} from './configuration';
import {APIConstants} from "./api-constants";
import {AppConstants} from "../index";


/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class UserProfileApi {
  protected basePath = '';
  public defaultHeaders: Headers = new Headers();
  public configuration: Configuration = new Configuration();
  
  constructor(
    protected http: Http, 
    protected apiConstants: APIConstants, 
    @Optional() configuration: Configuration) {
    
    this.basePath = this.apiConstants.APIURL;
    if (configuration) {
      this.configuration = configuration;
    }
    var storage = window.localStorage;
    var access = storage.getItem(AppConstants.API_ACCESS_TOKEN);
    this.configuration.accessToken = access;
    console.log("configuration accessToken", this.configuration.accessToken);
  }

  /**
   * update patient
   * This can only be done by the logged in user.
   * @param deviceToken mobile device token
   * @param deviceType mobile device type
   * @param userId user resource id
   */
  public saveUserDeviceToken(deviceToken: string, deviceType: string, userId: number, extraHttpRequestParams?: any): Observable<models.SuccessResponse> {
    return this.saveUserDeviceTokenWithHttpInfo(deviceToken, deviceType, userId, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json();
        }
      });
  }

  /**
   * update patient
   * This can only be done by the logged in user.
   * @param deviceToken mobile device token
   * @param deviceType mobile device type
   * @param userId user resource id
   */
  public saveUserDeviceTokenWithHttpInfo(deviceToken: string, deviceType: string, userId: number, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + `/SaveDeviceToken/${userId}`;

    let queryParameters = new URLSearchParams();
    let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'deviceToken' is not null or undefined
    if (deviceToken === null || deviceToken === undefined) {
      throw new Error('Required parameter deviceToken was null or undefined when calling saveUserDeviceToken.');
    }
    // verify required parameter 'deviceType' is not null or undefined
    if (deviceType === null || deviceType === undefined) {
      throw new Error('Required parameter deviceType was null or undefined when calling saveUserDeviceToken.');
    }
    // verify required parameter 'userId' is not null or undefined
    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling saveUserDeviceToken.');
    }
    if (deviceToken !== undefined) {
      queryParameters.set('deviceToken', <any> deviceToken);
    }
    if (deviceType !== undefined) {
      queryParameters.set('deviceType', <any> deviceType);
    }


    // to determine the Content-Type header
    let consumes: string[] = [
      'application/json'
    ];

    // to determine the Accept header
    let produces: string[] = [
      'application/json'
    ];

    // authentication (elagy_auth2) required
    // oauth required
    if (this.configuration.accessToken) {
      headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
    }




    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Put,
      headers: headers,
      search: queryParameters
    });

    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any> Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

}
